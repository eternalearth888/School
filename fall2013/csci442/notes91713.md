q.2.19
- protect against denial of service attacks
- keeps private information private
- avoid man-in-the-middle attacks
- ensure proper verification
q.2.20
- determines which process gets the CPU next (fine-grained decision)
- determines which process to swap in/out of disk to/from memory (medium-grained decision)
	- thrashing is the situation where one is pagefaulting over and over again
-determines which processes are admitted to the system for processing (coarse-grained decision)
	- determines who gets in

4. System structure
SINGLE PROCESS
LAYERED SYSTEMS

Q.2.2.1
-efficiency issues: each layer adds overhead to the system (must communicate with layers below me to get the hardware)
-if one layer crashes, HOSED
- hard to modify the system (hard to add a layer, hard to update a layer, etc)
- definition: how to DEFINE the layers (what goes in what layer, stacking)

Microkernel
Only include essential features in microkernel (e.g, IPC), best stability

Q.2.22
- modularity: easy to update a module (since uniform interfaces)
- layers are more independent
- reliability: layers are seperate AND small kernel can be rigorously tested
- security: once communication interface through microkernel AND process servers are NOT running in kernel mode
- flexibility: remove servers that you don't need, you can keep servers you need small
- extensibility: future OS functions can be easily added
- portability: small kernel so easy to port to different hardware


2.23
performance
bottleneck AND the cost to create/send/receive messages between the servers is a bit slow

What is more important? Speed or stability/security

Original Unix
1. system programs
2. kernel (HUGE)

- core kernel
- several loadable modules


2.24
- small core kernel
- any module can call any other module

a modular OS has monolithic structre .. BUT has added structure

2.25
method to request that the OS do ONE thing

2.27
one ore more systems calls (e.g.,cp)

2.26
1. process control
2. file manipulation
 "I would spell creat with an e"
 -information maintenance
 -device manipulation
 -communication



 cpid1=x
 cpid2=z
 	|			|
   	x			z
   cpid1=0		cpid1=x
   cpid2=you	cpid2=0
   |
   y
   cpid1=0
   cpid2=0

