// This file would normally be generated by Flex

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> 

#include "calc.tab.h"

#include "string.h"

  typedef enum { START, INTEGER, FLOAT_START, FLOAT, FLOAT_NO_E, FLOAT_E, MAGIC } numbers;
  typedef enum { T_INTEGER, T_FLOAT, T_BAD, T_EMPTY, T_EOF } tokenType;

int yylex(void)
{
  static int tokens = 0;

  int token;
  int yychar;

  char *yyString; // create a string object; allows for multi character concatenation
  yyString = malloc(256*sizeof(char)); // allocating memory for the String object
  yyString[0] = '\0'; // makes the first index of the 256 the null terminator

  char *yyStringHolder;  // allows for concatening a single character to the string
  yyStringHolder = malloc(2*sizeof(char)); // allocating memorry for the stringHolder object

  // set default state for enums
  numbers state = START;
  tokenType type = T_EMPTY;
//----------------------------------------------------------
// This code is junk placeholder code to give an initial
// lexer that will compile and run and do something.

// if read ahead using nextChar
int nextChar = fgetc(yyin);
if(nextChar)
{
  yychar = nextChar; 
  nextChar = 0;  
}
else 
{
  yychar = fgetc(yyin); // File assumed to be open and ready
}

// the get out of label for the case statement in the while loop
// our last resort for the numbers we are checking into
// else we would have to do a double break, which we can't do
SERENITY:
if (type == T_FLOAT)
{
 token = FLT;
 tokens++;
 yytext = (char *) malloc((strlen(yyString)+1)*sizeof(char));
 sprintf(yytext, "%c", yychar);
}

// tokenizing end of file
// exported upon detecting the end of the source code file
// value is the total number of tokens in the file, not including <BAD> or debugging tokens
if (EOF == yychar)
{
  token = END;
  tokens++;
  yytext = (char *) malloc(11*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing open paranthesis
else if ('(' == yychar)
{
  token = OPAREN;
  tokens++;
  yytext = (char *) malloc(7*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing closed paranthesis
else if (')' == yychar)
{ 
  token = CPAREN;
  tokens++;
  yytext = (char *) malloc(7*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing assignment/equals
else if ('=' == yychar)
{
  // printf("%s\n", "ASSIGN" );
  token = ASSIGN;
  tokens++;
  yytext = (char *) malloc(7*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokeninzing exponent
else if ('^' == yychar)
{
  // printf("%s\n", "EXPONENT");
  token = EXP;
  tokens++;
  yytext = (char *) malloc(4*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokening splat/multiplication/pointers
else if ('*' == yychar)
{
  token = MUL;
  tokens++;
  yytext = (char *) malloc(4*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing addition
else if ('+' == yychar)
{
  token = ADD;
  tokens++;
  yytext = (char *) malloc(4*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing subtraction
else if ('-' == yychar)
{
  token = SUB;
  tokens++;
  yytext = (char *) malloc(4*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing semicolon
else if (';' == yychar)
{
  token = SEMI;
  tokens++;
  yytext = (char *) malloc(5*sizeof(char));
  sprintf(yytext, "%c", yychar);
}
// tokenizing new line
// whenever a newline is encountered that is NOT within a block comment
// output this token with the number of the line of the source code file
else if ('\n' == yychar)
{
  token = NEWLINE;
  tokens++;
  yytext = (char *) malloc(8*sizeof(char));
  sprintf(yytext, "%s", " ");
}
// tokenizing ID
// has possible lexeme values of {R0, R1, ..., R9}
// represents a register (or a variable)
// lexeme value is required for this to work
else if ('R' == yychar)
{
  token = ID;
  tokens++;

  int nextChar = fgetc(yyin);
  if(isdigit(nextChar))
  {
    yytext = (char *) malloc(3*sizeof(char));
    sprintf(yytext, "%c%c", yychar, nextChar);
  }
}
else if ('/' == yychar)
{
  // tokenizing divisions
  int nextChar = fgetc(yyin);;
  if (nextChar != '/' && nextChar != '*')
  {
    token = DIV;
    tokens++;
    yytext = (char *) malloc(4*sizeof(char));
    sprintf(yytext, "%c", yychar);
  }
  // tokenizing line comment
  // should be exported whenever an end of line commment is encountered
  // value (if included)  should be the first 20 characters of the comment
  // not including the // sequence that started the comment
  else if (nextChar == '/')
  {
    int numChar = 0;
    int nextChar = fgetc(yyin);
    while (nextChar != EOF && nextChar != '\n')
    {
      numChar++;
      yyString = (char *) realloc(yyString, (numChar+1)*sizeof(char));
      sprintf(yyStringHolder, "%c", nextChar);

      strcat(yyString, yyStringHolder);

      nextChar = fgetc(yyin);
    }
    yytext = malloc((strlen(yyString)+1)*sizeof(char));
    sprintf(yytext, "%s", yyString);
    token = EOLCMT;
    tokens++;
  }
  else if (nextChar == '*')
  {
    // tokenzing block comment
    // should be exported whenever a block comment is encountered
    // the value (if included) should be the first 20 characters of the comment
    // not including the /* or the */ sequences that delimit the comment
    int numChar = 0;
    int nextChar = fgetc(yyin);
    while (nextChar != EOF)
    {
      // printf("%s\n", "HEY! LISTEN!" );
      numChar++;
      yyString = (char *) realloc(yyString, (numChar+1)*sizeof(char));
      sprintf(yyStringHolder, "%c", nextChar);
      strcat(yyString, yyStringHolder);

      if (nextChar == '*')
      {
        numChar++;
        nextChar = fgetc(yyin);

        if (nextChar == '/')
        {
          yyString = (char *) realloc(yyString, (numChar+1)*sizeof(char));
          sprintf(yyStringHolder, "%c", nextChar);

          strcat(yyString, yyStringHolder);
          token = BLKCMT;
          tokens++;
          yytext = (char *) malloc((strlen(yyString)+1)*sizeof(char));
          sprintf(yytext, "%s", yyString);
          break;
        }
        else if (nextChar == EOF) 
        { 
          break; 
        }
        else
        {
          yyString = (char *) realloc(yyString, (numChar+1)*sizeof(char));
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
        }
      }
      else
      {
        nextChar = fgetc(yyin);
      }
    }

    if (nextChar == EOF)
    {
      token = BAD;
      yytext = (char *) malloc((strlen(yyString)+1)*sizeof(char));
      sprintf(yytext, "%s", yyString);
    }
  }
}
// tokenizing numbers
else if ((yychar >= '0' && yychar <= '9') || yychar == '.')
{

  if (isdigit(yychar))
  {
    sprintf(yyStringHolder, "%c", yychar);
    strcat(yyString, yyStringHolder);
    type = T_INTEGER;
  }

  int nextChar = fgetc(yyin);

  while (nextChar != EOF)
  {
    switch(state)
    {
      case START : 
        if (nextChar == '.')
        {
           state = FLOAT_START;
           sprintf(yyStringHolder, "%c", nextChar);
           strcat(yyString, yyStringHolder);
           type = T_BAD;
        }
        else if (isdigit(nextChar))
        {
          state = INTEGER;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
          type = T_INTEGER;
        }
        else
        {
          yychar = nextChar;
           goto SERENITY;
        }
        break;
      case INTEGER:
        if (isdigit(nextChar))
        {
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
        }
        else if (nextChar == '.')
        {
          state = FLOAT_NO_E;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
          type = T_FLOAT;
        }
        else if (nextChar == 'E')
        {
          state = FLOAT_E;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
          type = T_BAD;
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
      case FLOAT_START:
        if (isdigit(nextChar))
        {
           state = FLOAT_NO_E;
           sprintf(yyStringHolder, "%c", nextChar);
           strcat(yyString, yyStringHolder);
           type = T_FLOAT;
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
      case FLOAT_NO_E:
        if (isdigit(nextChar))
        {
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
        }
        else if (nextChar == 'E')
        {
          state = FLOAT_E;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
          type = T_BAD;
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
      case FLOAT_E:
        if (nextChar == '+' || nextChar == '-')
        {
          state = MAGIC;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
      case MAGIC:
        if (isdigit(nextChar))
        {
          state = FLOAT;
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
          type = T_FLOAT;
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
      case FLOAT:
        if (isdigit(nextChar))
        {
          sprintf(yyStringHolder, "%c", nextChar);
          strcat(yyString, yyStringHolder);
        }
        else
        {
          yychar = nextChar;
          goto SERENITY;
        }
        break;
    }
    nextChar = fgetc(yyin);
    yychar = nextChar;
  }
}
// token is used whenever the lexer is unable to form a valid token
// any time that the lexer encounters a character that does not extend the present proto-lexeme
// but for which the present proto-lexeme is not an actual lexeme should e mapped to the <BAD>
// token with the proto-lexme
// exception: if the lexer is in the Start state when the bad token is generated
else
{
  token = BAD;
  yytext = (char *) malloc(4*sizeof(char));
  if (isgraph(yychar)&&('#' != yychar))
    sprintf(yytext, "%c", yychar);
  else
    sprintf(yytext, "#%02X", (yychar&0xFF));
}

// Freeing the memory for the String and StringHolder objects
// yytext is automatically freed in calc.tab.c
// yychar should not be freed because it still being passed into other things

free(yyString);
free(yyStringHolder);
//----------------------------------------------------------

return token;
}

int main(int argc, char *argv[])
{

  if (argc <= 1)
  {
    printf("USAGE: calc inputfilename\n");
    exit(EXIT_FAILURE);
  }

  yyparse(argv[1]);

  printf("Hit ENTER to exit.");
  fgetc(stdin);

  return 0;
}
